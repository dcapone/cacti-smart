#!/usr/bin/perl
use strict;
use warnings;
# Copyright (C) 2009-2011 Glen Pitt-Pladdy
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
#
#
# See: http://www.pitt-pladdy.com/blog/_20091031-144604_0000_SMART_stats_on_Cacti_via_SNMP_/
#
# Put SMART parameter ID on command line, prefixed by 'R' if you want raw value
#
# Put "worst" on the command line and the smallest gap to threshold of all
# parameters will be output.
#
# Version 20121118

my $FILES = '/var/local/snmp/smart';

# By default we assume max of 100 and scale against the threshold
# For special cases we have a database of parameters that need scaling differently
# By setting the scale to U that will be returned instead - ie. hides invalid params
my %SCALEBYFAMILY = (
	'Seagate Barracuda 7200.10' => {
#		7 => 2,		# Seek Errors has Thresh 30, but still sits mid-range on all drives
		195 => 1.429,	# ECC Recovered seems to sit about 70 on all drives
		199 => 0.5,		# UDMA CRC Errors seems to sit about 200 on all drives
	},
	'Seagate Barracuda 7200.12 family' => {
#		7 => 2,		# Seek Errors has Thresh 30, but still sits mid-range on all drives
		195 => 2,		# ECC Recovered seems to sit about 50 on all drives
		199 => 0.5,		# UDMA CRC Errors seems to sit about 200 on all drives
	},
	'Western Digital Caviar Black' => {
		1 => 0.671,		# Raw Read Errors seems to sit about 200 with thresh 51
		3 => 0.478,		# Spin Up Time seems to start about 230 with thresh 21
		5 => 1.667,		# Reallocated Sectors seems to sit at 200 with tresh 140
		196 => 0.5,		# Reallocated Events seems to sit at 200
		199 => 0.5,		# UDMA CRC Errors seems to sit at 200
	},
	'Western Digital Caviar Blue Serial ATA' => {
		1 => 0.671,		# Raw Read Errors seems to sit about 200 with thresh 51
		3 => 0.478,		# Spin Up Time seems to start about 230 with thresh 21
		5 => 1.667,		# Reallocated Sectors seems to sit at 200 with tresh 140
		196 => 0.5,		# Reallocated Events seems to sit at 200
		199 => 0.5,		# UDMA CRC Errors seems to sit at 200
	},
	'SandForce Driven SSDs' => {
		1 => 1.429,		# Raw Read Errors seems to start at 120 with thresh 50... on some
		171 => 'U',		# Program_Fail_Count is 0
		172 => 'U',		# Erase_Fail_Count is 0
		174 => 'U',		# Unexpect_Power_Loss_Ct is 0
		177 => 'U',		# Wear_Leveling_Count is 0
		181 => 'U',		# Program_Fail_Cnt_Total is 0
		182 => 'U',		# Erase_Fail_Count_Total is 0
		195 => 0.833,	# ECC Recovered seems to start at 120... on some
		196 => 0.833,	# Reallocated Events seems to start at 120... on some
		201 => 0.833,	# Soft Read Errors seems to start at 120.... on some
		204 => 0.833,	# Soft ECC Correction seems to start at 120.... on some
		233 => 'U',		# Media_Wearout_Indicator is 0
		234 => 'U',		# Unknown_Attribute / SandForce_Internal is 0
		241 => 'U',		# Lifetime_Writes_GiB is 0
		242 => 'U',		# Lifetime_Reads_GiB is 0
	},
);
my %SCALEBYMODEL = (
	'ST3250310AS' => $SCALEBYFAMILY{'Seagate Barracuda 7200.10'},
	'ST31000524AS' => $SCALEBYFAMILY{'Seagate Barracuda 7200.12 family'},
	'OCZ-AGILITY3' => $SCALEBYFAMILY{'SandForce Driven SSDs'},
	'SAMSUNG SSD PM830 FDE 2.5" 7mm 256GB' => {
		195 => 0.5,		# ECC Recovered seems to start at 200
		199 => 0.395,	# UDMA CRC Errors seems to start a 253... perhaps 255?
	},
);



my $param = shift @ARGV;
my $devicelist = 0;
my $worst = 0;
my $raw;
if ( $param eq 'devices' ) {
	$devicelist = 1;
} elsif ( $param =~ /^worst$/i ) {
	$worst = 1;
} elsif ( $param =~ s/^[rR](\d+)$/$1/ ) {
	$raw = 1;
} elsif ( $param =~ /^\d+$/ ) {
	$raw = 0;
} elsif ( lc $param eq 'description' ) {
	# nothing to do
} else {
	die "FATAL - need the numeric parameter or 'description' to show\n";
}

# run through current drives
opendir LS, "/dev" or die "FATAL - can't list /dev: $!\n";
my @drives;
while ( defined ( my $drive = readdir LS ) ) {
	if ( $drive !~ /^sd[a-z]$/ ) { next; }	# skip non drives
	push @drives, $drive
}
closedir LS;

if ( $devicelist ) {
	foreach my $drive (sort @drives) {
		print "/dev/$drive\n";
	}
	exit 0;
}

foreach my $drive (sort @drives) {
	# deal with missing files
	if ( ! -f "$FILES-$drive" ) {
		print "NA\n";
		next;
	}
	# grab the parameter from the file
	open DR, "$FILES-$drive"
		or die "FATAL - can't read \"$FILES-$drive\": $!\n";
	my $line;
	my $family;
	my $model;
	my $serial;
	my $firmware;
	my $capacity;
	while ( defined ( $line = <DR> )
		and $line !~ /^ID#\s+ATTRIBUTE_NAME\s+FLAG\s+VALUE\s+WORST\s+THRESH/ )
		{
		if ( $line =~ /^Model Family:\s*(\w.*)$/ ) {
			$family = $1;
		} elsif ( $line =~ /^Device Model:\s*(\w.*)$/ ) {
			$model = $1;
		} elsif ( $line =~ /^Serial Number:\s*(\w.*)$/ ) {
			$serial = $1;
		} elsif ( $line =~ /^Firmware Version:\s*(\w.*)$/ ) {
			$firmware = $1;
		} elsif ( $line =~ /^User Capacity:\s*(\d[\d\,]*) bytes/ ) {
			my $cap = $1;
			my $unit = 'B';
			for ('kB','MB','GB','TB','PB') {
				if ( $cap !~ s/,\d{3}$// ) { last; }
				$unit = $_;
			}
			$capacity = "$cap $unit"
		}
	}
	if ( lc $param eq 'description' ) {
		my $description = '';
		if ( defined $model ) { $description .= " $model"; }
		if ( defined $serial ) { $description .= " (SN $serial)"; }
		if ( defined $firmware ) { $description .= " [$firmware]"; }
		if ( defined $capacity ) { $description .= " $capacity" }
		$description =~ s/^\s+//;
		print "$description\n";
		next;
	}
	my $worstcase = 255;
	my $health;
	while ( defined ( my $line = <DR> ) ) {
		chomp $line;
		if ( $line eq '' ) { last; }
		$line =~ s/^\s*//;
		my @fields = split /\s+/, $line;
		if ( $worst and $fields[3] ne '---' and $fields[5] ne '---' ) {
			$health = $fields[3] - $fields[5];
			if ( defined $family and exists $SCALEBYFAMILY{$family}
				and exists $SCALEBYFAMILY{$family}{$param} ) {
				$health *= $SCALEBYFAMILY{$family}{$param}
			} elsif ( defined $model
				and exists $SCALEBYMODEL{$model}{$param} ) {
				if ( $SCALEBYMODEL{$model}{$param} eq 'U' ) {
					$health = 'U';
				} else {
					$health *= $SCALEBYMODEL{$model}{$param}
				}
			} elsif ( $fields[5] < 100 ) {
				# we assume we can scale against 100
				$health *= 100 / ( 100 - $fields[5] )
			}
			if ( $health < $worstcase ) {
				$worstcase = $health;
			}
			next;	# go no further
		}
		if ( $fields[0] != $param ) { next; }
		if ( $raw ) {
			$health = $fields[9];
			# we want the raw value
			print "$health\n";
		} else {
			if ( $fields[3] eq '---' or $fields[5] eq '---' ) {
				print "U\n";
				last;
			}
			# how close are we to threshold?
			$health = $fields[3] - $fields[5];
			if ( defined $family and exists $SCALEBYFAMILY{$family}
				and exists $SCALEBYFAMILY{$family}{$param} ) {
				$health *= $SCALEBYFAMILY{$family}{$param}
			} elsif ( defined $model
				and exists $SCALEBYMODEL{$model}{$param} ) {
				if ( $SCALEBYMODEL{$model}{$param} eq 'U' ) {
					$health = 'U';
				} else {
					$health *= $SCALEBYMODEL{$model}{$param}
				}
			} elsif ( $fields[5] < 100 ) {
				# we assume we can scale against 100
				$health *= 100 / ( 100 - $fields[5] )
			}
			print "$health\n";
			last;
		}
	}
	close DR;
	if ( $worst ) {
		print "$worstcase\n";
	} elsif ( ! defined ( $health ) ) {	# TODO this is broken - when worst is specified we should display the worst parameter - if last is undef then we get NA
		# didn't get the parameter
		print "NA\n";
	}
}
